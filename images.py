import numpy as np
import cv2

import math

class TemplateImage():
	"""
	This class contains all of the properties and functions of the image to be
	used as a template for the mosaic.
	"""

	def __init__(self, file_path, division_size):
		"""
		Initialize an instance of TemplateImage

		-Parameters-

		file_path:		path of the image file to be used

		division_size:	side length of the component mosaic images, used to
						determine the average colour and shading for each 
						component image.

		-Properties-

		.image:			numpy array of RGB values, as imported by OpenCV

		.height			height of image, in pixels
		
		.width			width of image, in pixels

		.scale 			scale image is to be shrunk to in order to make an
						RGB value template

		.template 		scaled version of image, each pixel representing
						an average RGB value for a photo to be used
						in the mosaic.
		"""

		self.image = import_image(file_path)
		self.height, self.width, self.rgb_values = self.image.shape
		self.scale = 1 / division_size
		
		self.template = scale_image(self.image, ratio=self.scale)
		self.template_height, self.template_width, self.template_rgb_values = (
			self.template.shape)


class ElementImage():
	"""This class contains all of the properties of an image to be used
	as part of the mosaic.
	"""

	def __init__(self, file_path, width):
		"""
		Initialize an instace of MosaicImage

		-Parameters-

		file_path:		path of the image file to be used

		width:			desired width for the mosaic image. Image is square
						so a height parameter is not used.
		"""

		self.original = import_image(file_path)
		self.width = width
		self.height = width # It's hip to be a square
		self.scaled = scale_image(self.original, dims=(self.width, self.height))
		self.cropped = crop_image(
							image = self.scaled,
							crop_x = self.width,
							crop_y = self.height,
							anchor = 'mm'
							)
		self.image = self.cropped
		self.rgb = average_rgb_values(self.image)


def import_image(file_path):
	"""
	Given the file_path of an image, returns a numpy array of RGB values
	representing the image. If an error occurs, returns None.
	"""

	try:
		img = cv2.imread(file_path)
	except:
		return None

	return img


def scale_image(image, ratio=1, dims=None):
	"""
	Given an image, returns a scaled version to the size specified. Maintains
	image proportions.

	image: 		a numpy array in the format produced by OpenCV, representing
				the RGB values of each pixel of an image.

	args: 		a float for the scale ratio to be used. This is a decimal
				value and not a percent (i.e. pass 0.6 and not 60 for 60%).
	"""

	# because typing is hard
	img = image

	# get size and area of the original image
	img_y, img_x, rgb_values = image.shape

	if dims:
		# get constraining dimension and change dims to preserve proportions
		sc_x, sc_y = dims
		ratio_x = sc_x / img_x
		ratio_y = sc_y / img_y
		ratio = max(ratio_x, ratio_y)

	# Use scale ration to determine dims to pass to the cv2 resize function
	sc_y = math.ceil(img_y * ratio)
	sc_x = math.ceil(img_x * ratio)		
	dims = sc_x, sc_y

	# return the resized image
	return cv2.resize(img, dims, interpolation=cv2.INTER_AREA)


def crop_image(image, crop_x, crop_y, anchor='tl'):
	"""
	Given an input image and desired x- and y-dimensions (in pixels), returns
	a cropped version of the image. Image must be a numpy array of RGB values
	(as generated by OpenCV), x- and y- dimensions must be passed as integers.

	By default, the right and bottom portions
	of the image are cropped (top left orientation). If a different anchor point
	for cropping is desired, pass the anchor string as one of the following:

		'tl': top left (default)
		'tm': top middle
		'tr': top right
		'ml': middle left
		'mm': middle
		'mr': middle right
		'bl': bottom left
		'bm': bottom middle
		'br': bottom right

	If anchor is not one of the above values, anchor will default to top left.
	If crop_x or crop_y are larger than the original image, the function will
	return None.
	"""

	# Check for valid anchor input
	anchors = ['tl', 'tm', 'tr', 'ml', 'mm', 'mr', 'bl', 'bm', 'br',]
	if anchor not in anchors:
		anchor = 'tl'

	# Get dimensions of orignal image and check validity of crop dimensions
	img_y, img_x, rgb_values = image.shape
	if crop_x > img_x or crop_y > img_y:
		return None

	# Get crop anchoring variables:
	anchor_x = anchor[-1]
	anchor_y = anchor[0]

	# Get x- and y- start points for extracting the cropped image
	# x start and end points
	if anchor_x == 'm':
		start_x = (img_x//2) - (crop_x//2)
	elif anchor_x == 'r':
		start_x = img_x - crop_x
	else:
		start_x = 0
	end_x = start_x + crop_x

	# y start and end points
	if anchor_y == 'm':
		start_y = (img_y//2) - (crop_y//2)
	elif anchor_y == 'b':
		start_y = img_y - crop_y
	else:
		start_y = 0
	end_y = start_y + crop_y

	# Extract the image data from the desired portion of the original image
	return image[start_y : end_y, start_x : end_x]


def average_rgb_values(image):
	"""
	Given an image, returns the average RGB values for the image.

	image:		a numpy array in the format produced by OpenCV, representing
				the RGB values of each pixel of an image.
	"""

	# get size and area of the image, and set color value totals
	img = image
	img_x, img_y, rgb_values = image.shape
	pixels = img_x * img_y
	r_tot, g_tot, b_tot = 0, 0, 0

	# loop through y- and x-dims of the array, summing up rgb values
	y = 0
	while y < img_y:
		x = 0
		while x < img_x:
			r_tot += img[y,x,0]
			g_tot += img[y,x,1]
			b_tot += img[y,x,2]
			x += 1
		y += 1

	# get average of rgb values
	r_avg = r_tot//pixels
	g_avg = g_tot//pixels
	b_avg = b_tot//pixels

	return r_avg, g_avg, b_avg